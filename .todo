-- ENGINE --

TODO
	P0

		[ ] Shader refactoring
			[ ] Load all shader uniform locations at the start
			[ ] Use pipelines for the other shaders?
		[ ] Renderer refactoring > Do this if you're bored
			[ ] just move functions around, create new files, delete others and stop worrying about that legacy of vulkan. 

	P1
		[ ] Animations
			[X] Store transforms as TRS
			[X] Lerp
			[ ] Animate a property by hand
			[ ] Link an animation to a property
			[ ] Make it move!
		[ ] Sky diffraction
		[ ] Volumetric clouds
		[ ] Audio

	P2
		[ ] Figure out how to handle freeing meshes/transforms from our dyntables
			[ ] Flag some spaces as free, maybe have a table that lists all the free spots.
			[ ] Make it cleanup itself on its own
		[ ] Figure out multithreading
		[ ] Fix hot reloading
			[ ] Basically we need to store what was loaded and reload it. 
			[ ] Restructure the two big structs (GameData & Renderer)
				[ ] Renderer fetches what it needs from GameData upon reload. 
				[ ] Everything is stored as ptrs in GameData so we need to overwrite these guys upon reloading
		[ ] Memory allocator?
		[ ] Profiling
        [ ] Handle multiple primitives in single gltf

--------
DOING


--------
DONE

	[X] Log to the console AND the game
	[X] Skinned meshes
	[X] Cleanup utils
	[X] Transforms

--------        

-- GAME DESIGN --

TODO
	[ ] Dialog
		[ ] Beep beeps Ã  la Phoenix Wright
	[ ] NPC Schedules
	[ ] Combat v0.1
	[ ] Buildings & Interiors
	[ ] Quests

--------
DOING



--------
DONE






















-----

VULKAN RENDERER:
    CRITICAL:
        - Resize the texture array, rebuild the pipeline?
        - Reloading the renderer doesn't reload the meshes and stuff
            ? Should we kill renderer hot reloading?
            - Mesh data (buffers, textures) prevents us from hot reloading
                ? Game could store all the loaded meshes and their instance data and send it back to the renderer on reload.
                ? Spliting the renderer in two (backend/frontend) could make it possible to reload the backend only.
                    > Frontend has mesh data and all and sends it to the backend on reload
                    > Backend is the current stuff
                ? Push all rendering data each frame. Seems dumbs but it could work. Easy to multithread. Works with a procedural approach.
        - Dynamic array of meshes
            - Take a decision on frontend/backend first
        ? Split the way we store render data
            > Renderer has list of meshes
            > Game has pointer to these meshes and their xform info
                > To render, pack this all up and send it to the renderer
        - !!!!Make sure that we can load different GLTF, I think the mat id and tex id are hardcoded

    MAJOR:
        - Have a way to update render groups without recreating the whole thing? What we do in UpdateWindow is kind of a cheat.
        - Dynamic Volumetric Fog resolution for perf

    BACKLOG:
        - UI

    IMPROVEMENTS:
        - Can't create a scene without textures
        - IBL?
        - Utiliser des Staging buffers
        - Pipeline caches
        - Pick the device according to our specs
        - Pipeline dynamic state
        - Apparently we should only allocate big stacks of memory
    IDEAS:
        - Volumetric clouds
        - Mipmaps
        - Have a look at vkCmdDrawIndirect
        - Maybe use rayquery for shadows?
        - Group descrptor sets
            - Descriptor set 0 > could be the same for all pipelines
            > Could have the camera matrices and the shadowmap sampler

            GLTF:
    CRITICAL:
    MAJOR:
        - If we have multiple meshes that use the same primitve, right now we just duplicate it
        - Read embedded glb
    BACKLOG:
    IMPROVEMENTS:
    IDEAS:
        - This is our last dependency. It looks super annoying to handle.